[题目]
	服务器生成一个静态随机整数列表，客户端通过 UDP 协议获取这些整数。
	最后输出全部整数的总和以及中位数。
	评分以结果准确度和传输性能评估最佳成绩。

	中位数是指数字序列，按从小到大排序：
	如果数字个数为单，则取最中间大小的那个数。
	如果数字个数为双，则取最中间两个数的平均值。

[数据]
	整数列表：
		* 正整数（全部大于 0），类型为 int32（32 位有符号整数）
		* 百万级别个整数
		* 不重复
		* 大小乱序
	过程：
		* 客户端通过协议，每个请求获取一定范围整数
		* 直到所有整数都获取完成或差不多获取完
	客户端计算结果：
		* 获取到的整数的总和
		* 获取到的整数的中位数

[协议]
	基本协议：UDP
	服务器：指定 IP:Port
	封包格式：二进制，网络字节序，一般以 int32 为字段

	请求：
		int32	本次请求整数开始下标
		int32	本次请求整数个数
		int32	每个 UDP 包返回整数个数

	回复：
		int32	整数总数量
		int32	本回复包的起始下标
		int32	本回复包的整数个数
		int32[]	本回复包的整数集合

	请求整数个数为 0 时，依然会有应答。相当于只返回总数。
	请求整数超出范围部分被忽略，但至少保证会有一个如上的应答。

	每个请求一旦被处理，服务器就不间断地回复其请求的全部整数。
	当然，回复速度取决于带宽。

[示例]
	a) 整数列表：[4 2 9 3 10]
	   总和：38
	   中位数：4

	b) 整数列表：[4 2 9 3 10]

	   请求0：<0, 0, 0>
	   回复0：<5, 0, 0, []>

	   请求1：<0, 1, 0>
	   回复1：<5, 0, 1, [4]>

	   请求2：<1, 4, 2>
	   回复2：<5, 1, 2, [2 9]>
	   回复2：<5, 3, 2, [3 10]>

	   请求3：<-1, 0, 0>
	   回复3：<5, 0, 0, []>

	   请求4：<0, 1, 0>
	   回复4：<5, 0, 0, []>

[测试干扰]
	固有干扰因素：
		* 丢包：虽然测试时可能在局域网，已经比较可靠，但还是可能会出现丢包
		* 延时：测试带宽毕竟有限，所以发送数据时会存在各种延时

	人为干扰因素：
		* 接收丢包：服务器按比例丢弃收到的请求包
		* 发送丢包：服务器按比例丢弃部分回复包
		* 接收延时：服务器虽然收到请求包，但可能故意延时处理。这里不保证延时的分布

	以上三种人为因素可能配置为“丢包率”和“延时上限”两项。
	丢包率同时影响接收和发送。延时上限则影响请求的处理延时，最大延时不超过上限。

	丢包率可能会有 0%、2% 和 10% 三个级别。
	延时上限可能会有 0ms、50ms 和 200ms 三个级别。
	两种交叉，会有九种测试配置。

[评分]
	评分项共 4 个：
	1. 总和的差值
	2. 中位数的差值
	3. 处理用时
	4. CPU 占用
	其中 1、2 为准确性方面，3、4 为性能方面。

[服务端实现]
	默认服务器用 golang 实现，一个 UDP 接收的 goroutine，每个请求有独立回复的 goroutine。

[测试分期]
	第一期：
		不设置人为干扰因素。
		根据结果，总结评分方法。

	第二期：
		设置丢包率和处理延时，交叉得到九种配置。

